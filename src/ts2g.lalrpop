use crate::ast::{Expr, Statement};
use std::str::FromStr;
use std::f64;

grammar;

pub S: Vec<Box<Statement>> = Statement*;

pub Statement: Box<Statement> = {
    <Expr> ";" => Box::new(Statement::ExprStatement(<>)),
    "let" <id:ID> ":" <t:TYPE> "=" <expr:Expr> ";" => Box::new(Statement::Let(id.to_owned(), t.to_owned(), expr)),
    "print(" <Expr> ");" => Box::new(Statement::Print(<>)),
};

pub Expr: Box<Expr> = {
    #[precedence(level="0")]
    INT => Box::new(Expr::Number(<>)),
    ID => Box::new(Expr::Id(<>.to_owned())),
    PI => Box::new(Expr::PI),
    E => Box::new(Expr::E),
    #[precedence(level="1")]
    Parths => Box::new(Expr::Parenthesis(<>)),
    #[precedence(level="2")]
    #[assoc(side="right")]
    <l:Expr> "^" <r:Expr> => Box::new(Expr::Exponent(l, r)),
    #[precedence(level="3")]
    #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Box::new(Expr::Multiply(l, r)),
    <l:Expr> "/" <r:Expr> => Box::new(Expr::Divide(l, r)),
    #[precedence(level="4")]
    #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Box::new(Expr::Add(l, r)),
    <l:Expr> "-" <r:Expr> => Box::new(Expr::Sub(l, r)),
    #[precedence(level="5")]
    <id:ID> EQ <expr:Expr> => Box::new(Expr::Eq(id.to_owned(), expr)),
};
Parths: Box<Expr> = "(" <Expr> ")";

U8: &'input str = "u8";
I8: &'input str = "i8";
U16: &'input str = "u16";
I16: &'input str = "i16";
U32: &'input str = "u32";
I32: &'input str = "i32";
U64: &'input str = "u64";
I64: &'input str = "i64";
F32: &'input str = "f32";
F64: &'input str = "f64";
TYPE: &'input str = {
    U8,
    I8,
    U16,
    I16,
    U32,
    I32,
    U64,
    I64,
    F32,
    F64,
};
INT: f64 = r"-?[0-9]+(?:\.[0-9]+)?" => f64::from_str(<>).unwrap();
PI: &'input str = {
    "pi",
    "PI",
};
E: &'input str = "e";
LET: &'input str = "let";
ID: &'input str = r"([a-zA-Z])+";
EQ: &'input str = "=";
WS: &'input str = " \t\r\n";
